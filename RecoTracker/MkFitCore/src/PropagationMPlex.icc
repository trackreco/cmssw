///////////////////////////////////////////////////////////////////////////////
/// helixAtRFromIterativeCCS_impl
///////////////////////////////////////////////////////////////////////////////

//#define DEBUG
//#include "Debug.h"
#include "TrackingTools/AnalyticalJacobians/interface/AnalyticalCurvilinearJacobian.h"
#include "TrackingTools/TrajectoryParametrization/interface/GlobalTrajectoryParameters.h"
#include "DataFormats/TrajectoryState/interface/TrackCharge.h"


template <typename Tf, typename TfLL1>
static inline void parsFromPathL_impl(const Tf& __restrict__ inPar,
                                      TfLL1& __restrict__ outPar,
                                      const float* kinv,
                                      const float* s,
                                      const int nmin,
                                      const int nmax) {

  float alpha[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = s[n - nmin] * std::sin(inPar(n, 5, 0)) * inPar(n, 3, 0) * kinv[n - nmin];
  }

  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
    }
  } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      cosah[n - nmin] = std::cos(alpha[n - nmin] * 0.5f);
      sinah[n - nmin] = std::sin(alpha[n - nmin] * 0.5f);
    }
  }

  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 0, 0) = inPar(n, 0, 0) + 2.f * sinah[n - nmin] * (std::cos(inPar(n, 4, 0)) * cosah[n - nmin] - std::sin(inPar(n, 4, 0)) * sinah[n - nmin]) / (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 1, 0) = inPar(n, 1, 0) + 2.f * sinah[n - nmin] * (std::sin(inPar(n, 4, 0)) * cosah[n - nmin] + std::cos(inPar(n, 4, 0)) * sinah[n - nmin]) / (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 2, 0) = inPar(n, 2, 0) + alpha[n - nmin] / kinv[n - nmin] * std::cos(inPar(n, 5, 0)) / (inPar(n, 3, 0) * std::sin(inPar(n, 5, 0)));
    outPar(n, 3, 0) = inPar(n, 3, 0);
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    outPar(n, 5, 0) = inPar(n, 5, 0);
  }

}

//should kinv and D be templated???
template <typename Tf, typename Ti, typename TfLL1, typename TfLLL>
static inline void parsAndErrPropFromPathL_impl(const Tf& __restrict__ inPar,
                                                const Ti& __restrict__ inChg,
                                                TfLL1& __restrict__ outPar,
                                                const float* kinv,
                                                const float* s,
                                                TfLLL& __restrict__ errorProp,
                                                const int nmin,
                                                const int nmax,
                                                const int N_proc,
						const PropagationFlags& pf) {


  //iteration should return the path length s, then update parameters and compute errors

  parsFromPathL_impl(inPar,outPar,kinv,s,nmin,nmax);

  // use the function AnalyticalCurvilinearJacobian::computeFullJacobian for error propagation in curvilinear coordinates, then convert to CCS

  float cosPin[nmax - nmin];
  float sinPin[nmax - nmin];
  float cosPout[nmax - nmin];
  float sinPout[nmax - nmin];
  float cosT[nmax - nmin];
  float sinT[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    cosPin[n] = std::cos(inPar(n, 4, 0));
    sinPin[n] = std::sin(inPar(n, 4, 0));
    cosPout[n] = std::cos(outPar(n, 4, 0));
    sinPout[n] = std::sin(outPar(n, 4, 0));
    cosT[n] = std::cos(inPar(n, 5, 0));
    sinT[n] = std::sin(inPar(n, 5, 0));
  }

  MPlex55  errorPropCurv;
  for (int n = nmin; n < nmax; ++n) {
    AnalyticalCurvilinearJacobian acj;
    GlobalPoint sX(inPar(n, 0, 0),inPar(n, 1, 0),inPar(n, 2, 0));
    GlobalPoint eX(outPar(n, 0, 0),outPar(n, 1, 0),outPar(n, 2, 0));
    GlobalVector sP(cosPin[n]/inPar(n, 3, 0),sinPin[n]/inPar(n, 3, 0),cosT[n]/(sinT[n]*inPar(n, 3, 0)) );
    GlobalVector eP(cosPout[n]/outPar(n, 3, 0),sinPout[n]/outPar(n, 3, 0),cosT[n]/(sinT[n]*outPar(n, 3, 0)) );
    TrackCharge sQ(inChg(n, 0, 0));
    GlobalVector bF(0,0, (pf.use_param_b_field ? 0.01f * Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0))) : 0.01f * Const::sol * Config::Bfield) );
    acj.computeFullJacobian(GlobalTrajectoryParameters(sX, sP, sQ, 0, bF), eX, eP, bF, s[n - nmin]);
    auto& acjj = acj.jacobian();
    for (auto i = 0; i < 5; ++i) {
      for (auto j = 0; j < 5; ++j) {
        errorPropCurv(n, i, j) = acjj(i,j);
      }
    }

  }//end loop over n

//debug = true;
#ifdef DEBUG
    for (int n = nmin; n < nmax; ++n) {
      if (debug && g_debug && n < N_proc) {
        dmutex_guard;
        std::cout << n << ": errorPropCurv" << std::endl;
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 0, 0),
               errorPropCurv(n, 0, 1),
               errorPropCurv(n, 0, 2),
               errorPropCurv(n, 0, 3),
               errorPropCurv(n, 0, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 1, 0),
               errorPropCurv(n, 1, 1),
               errorPropCurv(n, 1, 2),
               errorPropCurv(n, 1, 3),
               errorPropCurv(n, 1, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 2, 0),
               errorPropCurv(n, 2, 1),
               errorPropCurv(n, 2, 2),
               errorPropCurv(n, 2, 3),
               errorPropCurv(n, 2, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 3, 0),
               errorPropCurv(n, 3, 1),
               errorPropCurv(n, 3, 2),
               errorPropCurv(n, 3, 3),
               errorPropCurv(n, 3, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 4, 0),
               errorPropCurv(n, 4, 1),
               errorPropCurv(n, 4, 2),
               errorPropCurv(n, 4, 3),
               errorPropCurv(n, 4, 4));
        printf("\n");
      }
    }
#endif

  //now we need jacobians to convert to/from curvilinear and CCS
  // code from TrackState::jacobianCCSToCurvilinear
  MPlex56  jacCCS2Curv;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii=0;ii<5;ii++) {
      for (int jj=0;jj<6;jj++) {
        jacCCS2Curv(n, ii, jj) = 0.f;
      }
    }
    jacCCS2Curv(n, 0, 3) = inChg(n, 0, 0) * sinT[n];
    jacCCS2Curv(n, 0, 5) = inChg(n, 0, 0) * cosT[n] * inPar(n, 3, 0);
    jacCCS2Curv(n, 1, 5) = -1.f;
    jacCCS2Curv(n, 2, 4) = 1.f;
    jacCCS2Curv(n, 3, 0) = -sinPin[n];
    jacCCS2Curv(n, 3, 1) = cosPin[n];
    jacCCS2Curv(n, 4, 0) = -cosPin[n] * cosT[n];
    jacCCS2Curv(n, 4, 1) = -sinPin[n] * cosT[n];
    jacCCS2Curv(n, 4, 2) = sinT[n];
  }

  // code from TrackState::jacobianCurvilinearToCCS
  MPlex65  jacCurv2CCS;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii=0;ii<6;ii++) {
      for (int jj=0;jj<5;jj++) {
        jacCurv2CCS(n, ii, jj) = 0.f;
      }
    }

    jacCurv2CCS(n, 0, 3) = -sinPout[n];
    jacCurv2CCS(n, 0, 4) = -cosT[n] * cosPout[n];
    jacCurv2CCS(n, 1, 3) = cosPout[n];
    jacCurv2CCS(n, 1, 4) = -cosT[n] * sinPout[n];
    jacCurv2CCS(n, 2, 4) = sinT[n];
    jacCurv2CCS(n, 3, 0) = inChg(n, 0, 0) / sinT[n];
    jacCurv2CCS(n, 3, 1) = outPar(n, 3, 0) * cosT[n] / sinT[n];
    jacCurv2CCS(n, 4, 2) = 1.f;
    jacCurv2CCS(n, 5, 1) = -1.f;
  }

  //need to compute errorProp = jacCurv2CCS*errorPropCurv*jacCCS2Curv
  Matriplex::MPlex<float, 6, 5, NN> tmp;
  Matriplex::multiplyGeneral(jacCurv2CCS, errorPropCurv, tmp);
  Matriplex::multiplyGeneral(tmp, jacCCS2Curv, errorProp);

}


// from P.Avery's notes (http://www.phys.ufl.edu/~avery/fitting/transport.pdf eq. 5)
float getS(float delta0, float delta1, float delta2,
           float eta0, float eta1, float eta2,
	   float sinP, float cosP, float sinT, float cosT,
	   float pt, int q, float kinv
           ) {
  float A = delta0*eta0 + delta1*eta1 + delta2*eta2;
  float ip = sinT/pt;
  float p0[3] = {pt*cosP,pt*sinP,cosT/ip};
  float B = (p0[0]*eta0 + p0[1]*eta1 + p0[2]*eta2) * ip;
  float rho = kinv*ip;
  float C = (eta0*p0[1] - eta1*p0[0]) * rho * 0.5f * ip;
  float sqb2m4ac = std::sqrt( B*B - 4.f*A*C );
  float s1 = (-B + sqb2m4ac)*0.5f/C;
  float s2 = (-B - sqb2m4ac)*0.5f/C;
  //take the closest
  return ( std::abs(s1)>std::abs(s2) ? s2 : s1);
}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtPlane_impl(const Tf& __restrict__ inPar,
                                     const Ti& __restrict__ inChg,
                                     const Tf11& __restrict__ plPnt,
                                     const Tf11& __restrict__ plNrm,
                                     TfLL1& __restrict__ outPar,
                                     TfLLL& __restrict__ errorProp,
                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                     const int nmin,
                                     const int nmax,
                                     const int N_proc,
                                     const PropagationFlags& pf) {
  float kinv[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f * (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0)) ) );
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f * (-Const::sol * Config::Bfield);
    }
  }

  float delta0[nmax - nmin];
  float delta1[nmax - nmin];
  float delta2[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    delta0[n] = inPar(n,0,0)-plPnt(n,0,0);
    delta1[n] = inPar(n,1,0)-plPnt(n,1,0);
    delta2[n] = inPar(n,2,0)-plPnt(n,2,0);
  }

  float sinP[nmax - nmin];
  float cosP[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinP[n] = std::sin(inPar(n,4,0));
    cosP[n] = std::cos(inPar(n,4,0));
  }

  float s[nmax - nmin];
  //first iteration outside the loop
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    s[n] = getS(delta0[n],delta1[n],delta2[n],plNrm(n,0,0), plNrm(n,1,0), plNrm(n,2,0), sinP[n], cosP[n],
                std::sin(inPar(n,5,0)), std::cos(inPar(n,5,0)), inPar(n,3,0), inChg(n,0,0), kinv[n]);
  }

  MPlexLV outParTmp;

  CMS_UNROLL_LOOP_COUNT(Config::Niter-1)
  for (int i = 0; i < Config::Niter-1; ++i) {

    parsFromPathL_impl(inPar, outParTmp, kinv, s, nmin, nmax);

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      delta0[n] = outParTmp(n,0,0)-plPnt(n,0,0);
      delta1[n] = outParTmp(n,1,0)-plPnt(n,1,0);
      delta2[n] = outParTmp(n,2,0)-plPnt(n,2,0);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sinP[n] = std::sin(outParTmp(n,4,0));
      cosP[n] = std::cos(outParTmp(n,4,0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      s[n] += getS(delta0[n],delta1[n],delta2[n],plNrm(n,0,0), plNrm(n,1,0), plNrm(n,2,0), sinP[n], cosP[n],
                   std::sin(inPar(n,5,0)), std::cos(inPar(n,5,0)), inPar(n,3,0), inChg(n,0,0), kinv[n]);
    }

  }//end Niter-1
std::cout << "s=" << s[0] << std::endl;
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, nmin, nmax, N_proc, pf);

}

// this function just calculates the path length (using the iterative approach as before)
// and then calls parsAndErrPropFromPathL_impl for error propagation
template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl_new(const Tf& __restrict__ inPar,
                                                     const Ti& __restrict__ inChg,
                                                     const Tf11& __restrict__ msRad,
                                                     TfLL1& __restrict__ outPar,
                                                     TfLLL& __restrict__ errorProp,
                                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                     const int nmin,
                                                     const int nmax,
                                                     const int N_proc,
                                                     const PropagationFlags& pf) {

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float oodotp[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(xin[n - nmin], yin[n - nmin]);
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * xin[n - nmin] + pyin[n - nmin] * yin[n - nmin]);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] / std::tan(inPar(n, 5, 0)) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n]);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      xin[n - nmin] = xin[n - nmin] + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      yin[n - nmin] = yin[n - nmin] + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float s[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    s[n - nmin] = D[n - nmin]/std::sin(inPar(n, 5, 0));
  }
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, nmin, nmax, N_proc, pf);

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation to R end (NEW), dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << D[n - nmin] * inPar(n, 3, 0) * kinv[n - nmin] << " kinv = " << kinv[n - nmin] << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
		  << " cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif

}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl(const Tf& __restrict__ inPar,
                                                 const Ti& __restrict__ inChg,
                                                 const Tf11& __restrict__ msRad,
                                                 TfLL1& __restrict__ outPar,
                                                 TfLLL& __restrict__ errorProp,
                                                 Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                 const int nmin,
                                                 const int nmax,
                                                 const int N_proc,
                                                 const PropagationFlags& pf) {
  // bool debug = true;

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
  float theta[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    // if (std::abs(r-r0)<0.0001f) {
    // 	dprint("distance less than 1mum, skip");
    // 	continue;
    // }

    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
    theta[n - nmin] = inPar(n, 5, 0);

    //dprint(std::endl);
  }

//debug = true;
  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float dDdx[nmax - nmin];
  float dDdy[nmax - nmin];
  float dDdipt[nmax - nmin];
  float dDdphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdipt[n - nmin] = 0.;
    dDdphi[n - nmin] = 0.;
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //derivatives initialized to value for first iteration, i.e. distance = r-r0in
    dDdx[n - nmin] = r0[n - nmin] > 0.f ? -xin[n - nmin] / r0[n - nmin] : 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdy[n - nmin] = r0[n - nmin] > 0.f ? -yin[n - nmin] / r0[n - nmin] : 0.f;
  }

  float oodotp[nmax - nmin];
  float x[nmax - nmin];
  float y[nmax - nmin];
  float oor0[nmax - nmin];
  float dadipt[nmax - nmin];
  float dadx[nmax - nmin];
  float dady[nmax - nmin];
  float pxca[nmax - nmin];
  float pxsa[nmax - nmin];
  float pyca[nmax - nmin];
  float pysa[nmax - nmin];
  float tmp[nmax - nmin];
  float tmpx[nmax - nmin];
  float tmpy[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(outPar(n, 0, 0), outPar(n, 1, 0));
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * outPar(n, 0, 0) + pyin[n - nmin] * outPar(n, 1, 0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] * std::tan(theta[n - nmin]) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n]);
    }

    //update derivatives on total distance
    if (i + 1 != Config::Niter) {
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        x[n - nmin] = outPar(n, 0, 0);
        y[n - nmin] = outPar(n, 1, 0);
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        oor0[n - nmin] =
            (r0[n - nmin] > 0.f && std::abs(r[n - nmin] - r0[n - nmin]) > 0.0001f) ? 1.f / r0[n - nmin] : 0.f;
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dadipt[n - nmin] = id[n - nmin] * kinv[n - nmin];
        dadx[n - nmin] = -x[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        dady[n - nmin] = -y[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        pxca[n - nmin] = pxin[n - nmin] * cosa[n - nmin];
        pxsa[n - nmin] = pxin[n - nmin] * sina[n - nmin];
        pyca[n - nmin] = pyin[n - nmin] * cosa[n - nmin];
        pysa[n - nmin] = pyin[n - nmin] * sina[n - nmin];
        tmpx[n - nmin] = k[n - nmin] * dadx[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdx[n - nmin] -= (x[n - nmin] * (1.f + tmpx[n - nmin] * (pxca[n - nmin] - pysa[n - nmin])) +
                           y[n - nmin] * tmpx[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin])) *
                          oor0[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        tmpy[n - nmin] = k[n - nmin] * dady[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdy[n - nmin] -= (x[n - nmin] * tmpy[n - nmin] * (pxca[n - nmin] - pysa[n - nmin]) +
                           y[n - nmin] * (1.f + tmpy[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin]))) *
                          oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        //now r0 depends on ipt and phi as well
        tmp[n - nmin] = dadipt[n - nmin] * ipt[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdipt[n - nmin] -= k[n - nmin] *
                            (x[n - nmin] * (pxca[n - nmin] * tmp[n - nmin] - pysa[n - nmin] * tmp[n - nmin] -
                                            pyca[n - nmin] - pxsa[n - nmin] + pyin[n - nmin]) +
                             y[n - nmin] * (pyca[n - nmin] * tmp[n - nmin] + pxsa[n - nmin] * tmp[n - nmin] -
                                            pysa[n - nmin] + pxca[n - nmin] - pxin[n - nmin])) *
                            pt[n - nmin] * oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdphi[n - nmin] += k[n - nmin] *
                            (x[n - nmin] * (pysa[n - nmin] - pxin[n - nmin] + pxca[n - nmin]) -
                             y[n - nmin] * (pxsa[n - nmin] - pyin[n - nmin] + pyca[n - nmin])) *
                            oor0[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      outPar(n, 0, 0) = outPar(n, 0, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      outPar(n, 1, 0) = outPar(n, 1, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float alpha[nmax - nmin];
  float dadphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = D[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadx[n - nmin] = dDdx[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dady[n - nmin] = dDdy[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadipt[n - nmin] = (ipt[n - nmin] * dDdipt[n - nmin] + D[n - nmin]) * kinv[n - nmin];
    dadphi[n - nmin] = dDdphi[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
  }

  if constexpr (Config::useTrigApprox) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin], sina[n - nmin], cosa[n - nmin]);
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = std::cos(alpha[n - nmin]);
      sina[n - nmin] = std::sin(alpha[n - nmin]);
    }
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 0, 0) = 1.f + k[n - nmin] * dadx[n - nmin] *
                                   (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 0, 1) = k[n - nmin] * dady[n - nmin] *
                         (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 0, 2) = 0.f;
    errorProp(n, 0, 3) =
        k[n - nmin] *
        (cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         sinPorT[n - nmin] * ((1.f - cosa[n - nmin]) - ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin])) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 0, 4) =
        k[n - nmin] *
        (cosPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] -
         sinPorT[n - nmin] * sina[n - nmin] + cosPorT[n - nmin] * cosa[n - nmin] - cosPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 0, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 1, 0) = k[n - nmin] * dadx[n - nmin] *
                         (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 1, 1) = 1.f + k[n - nmin] * dady[n - nmin] *
                                   (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 1, 2) = 0.f;
    errorProp(n, 1, 3) =
        k[n - nmin] *
        (sinPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin] - (1.f - cosa[n - nmin]))) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 1, 4) =
        k[n - nmin] *
        (sinPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] +
         sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin] - sinPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 1, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //no trig approx here, theta can be large
    cosPorT[n - nmin] = std::cos(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //redefine sinPorT as 1./sinPorT to reduce the number of temporaries
    sinPorT[n - nmin] = 1.f / sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 2, 0) =
        inPar(n, 2, 0) + k[n - nmin] * alpha[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 0) = k[n - nmin] * cosPorT[n - nmin] * dadx[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 1) = k[n - nmin] * cosPorT[n - nmin] * dady[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 2, 3) = k[n - nmin] * cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] - alpha[n - nmin]) *
                         pt[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 4) = k[n - nmin] * dadphi[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 5) = -k[n - nmin] * alpha[n - nmin] * pt[n - nmin] * sinPorT[n - nmin] * sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 3, 0) = ipt[n - nmin];
    errorProp(n, 3, 0) = 0.f;
    errorProp(n, 3, 1) = 0.f;
    errorProp(n, 3, 2) = 0.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 3, 4) = 0.f;
    errorProp(n, 3, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    errorProp(n, 4, 0) = dadx[n - nmin];
    errorProp(n, 4, 1) = dady[n - nmin];
    errorProp(n, 4, 2) = 0.f;
    errorProp(n, 4, 3) = dadipt[n - nmin];
    errorProp(n, 4, 4) = 1.f + dadphi[n - nmin];
    errorProp(n, 4, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 5, 0) = theta[n - nmin];
    errorProp(n, 5, 0) = 0.f;
    errorProp(n, 5, 1) = 0.f;
    errorProp(n, 5, 2) = 0.f;
    errorProp(n, 5, 3) = 0.f;
    errorProp(n, 5, 4) = 0.f;
    errorProp(n, 5, 5) = 1.f;
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation end, dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << alpha[n - nmin] << " kinv = " << kinv[n - nmin] << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
		  << "   cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif
}
