///////////////////////////////////////////////////////////////////////////////
/// helixAtRFromIterativeCCS_impl
///////////////////////////////////////////////////////////////////////////////

//#define DEBUG
//#include "Debug.h"

template <typename Tf, typename TfLL1>
static inline void parsFromPathL_impl(const Tf& __restrict__ inPar,
                                      TfLL1& __restrict__ outPar,
                                      const float* kinv,
                                      const float* s,
                                      const int nmin,
                                      const int nmax) {

  float alpha[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = s[n - nmin] * std::sin(inPar(n, 5, 0)) * inPar(n, 3, 0) * kinv[n - nmin];
  }

  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
    }
  } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      cosah[n - nmin] = std::cos(alpha[n - nmin] * 0.5f);
      sinah[n - nmin] = std::sin(alpha[n - nmin] * 0.5f);
    }
  }

  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 0, 0) = inPar(n, 0, 0) + 2.f * sinah[n - nmin] * (std::cos(inPar(n, 4, 0)) * cosah[n - nmin] - std::sin(inPar(n, 4, 0)) * sinah[n - nmin]) / (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 1, 0) = inPar(n, 1, 0) + 2.f * sinah[n - nmin] * (std::sin(inPar(n, 4, 0)) * cosah[n - nmin] + std::cos(inPar(n, 4, 0)) * sinah[n - nmin]) / (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 2, 0) = inPar(n, 2, 0) + alpha[n - nmin] / kinv[n - nmin] * std::cos(inPar(n, 5, 0)) / (inPar(n, 3, 0) * std::sin(inPar(n, 5, 0)));
    outPar(n, 3, 0) = inPar(n, 3, 0);
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    outPar(n, 5, 0) = inPar(n, 5, 0);
  }

}

//should kinv and D be templated???
template <typename Tf, typename Ti, typename TfLL1, typename TfLLL>
static inline void parsAndErrPropFromPathL_impl(const Tf& __restrict__ inPar,
                                                const Ti& __restrict__ inChg,
                                                TfLL1& __restrict__ outPar,
                                                const float* kinv,
                                                const float* s,
                                                TfLLL& __restrict__ errorProp,
                                                const int nmin,
                                                const int nmax,
                                                const int N_proc,
						const PropagationFlags& pf) {


  //iteration should return the path length s, then update parameters and compute errors

  parsFromPathL_impl(inPar,outPar,kinv,s,nmin,nmax);

  float cosPin[nmax - nmin];
  float sinPin[nmax - nmin];
  float cosPout[nmax - nmin];
  float sinPout[nmax - nmin];
  float cosT[nmax - nmin];
  float sinT[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    cosPin[n] = std::cos(inPar(n, 4, 0));
    sinPin[n] = std::sin(inPar(n, 4, 0));
    cosPout[n] = std::cos(outPar(n, 4, 0));
    sinPout[n] = std::sin(outPar(n, 4, 0));
    cosT[n] = std::cos(inPar(n, 5, 0));
    sinT[n] = std::sin(inPar(n, 5, 0));
  }

  // use code from AnalyticalCurvilinearJacobian::computeFullJacobian for error propagation in curvilinear coordinates, then convert to CCS
  // main difference from the above function is that we assume that the magnetic field is purely along z (which also implies that there is no change in pz)

  MPlex55  errorPropCurv;
  for (int n = nmin; n < nmax; ++n) {

    float qbp = inChg(n, 0, 0)*sinT[n]*inPar(n, 3, 0);
    float absS = s[n - nmin];
    // calculate transport matrix
    // Origin: TRPRFN
    float t11 = cosPin[n]*sinT[n];
    float t12 = sinPin[n]*sinT[n];
    float t13 = cosT[n];
    float t21 = cosPout[n]*sinT[n];
    float t22 = sinPout[n]*sinT[n];
    float t23 = cosT[n];
    float cosl0 = sinT[n];
    float cosl1 = 1. / sinT[n];
    // define average magnetic field and gradient
    // at initial point - inlike TRPRFN
    float bF = (pf.use_param_b_field ? 0.01f * Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0))) : 0.01f * Const::sol * Config::Bfield);
    float qp = -bF;
    float q = qp * qbp;
    float theta = q * absS;
    //float sint, cost;
    //vdt::fast_sincos(theta, sint, cost);
    float sint = std::sin(theta);
    float cost = std::cos(theta);
    float hn1 = 0.f;
    float hn2 = 0.f;
    float hn3 = 1.f;
    float dx1 = inPar(n, 0, 0)-outPar(n, 0, 0);
    float dx2 = inPar(n, 1, 0)-outPar(n, 1, 0);
    float dx3 = inPar(n, 2, 0)-outPar(n, 2, 0);
    float gamma = hn1 * t21 + hn2 * t22 + hn3 * t23;
    float an1 = hn2 * t23 - hn3 * t22;
    float an2 = hn3 * t21 - hn1 * t23;
    float an3 = hn1 * t22 - hn2 * t21;
    float au = 1. / sqrt(t11 * t11 + t12 * t12);
    float u11 = -au * t12;
    float u12 = au * t11;
    float v11 = -t13 * u12;
    float v12 = t13 * u11;
    float v13 = t11 * u12 - t12 * u11;
    au = 1. / sqrt(t21 * t21 + t22 * t22);
    float u21 = -au * t22;
    float u22 = au * t21;
    float v21 = -t23 * u22;
    float v22 = t23 * u21;
    float v23 = t21 * u22 - t22 * u21;
    // now prepare the transport matrix
    float anv = -(hn1 * u21 + hn2 * u22);
    float anu = (hn1 * v21 + hn2 * v22 + hn3 * v23);
    float omcost = 1. - cost;
    float tmsint = theta - sint;
    float hu1 = -hn3 * u12;
    float hu2 = hn3 * u11;
    float hu3 = hn1 * u12 - hn2 * u11;
    float hv1 = hn2 * v13 - hn3 * v12;
    float hv2 = hn3 * v11 - hn1 * v13;
    float hv3 = hn1 * v12 - hn2 * v11;
    //   1/p - doesn't change since |p1| = |p2|
    errorPropCurv(n, 0, 0) = 1.;
    for (auto i = 1; i < 5; ++i) errorPropCurv(n, 0, i) = 0.;
    //   lambda
    errorPropCurv(n, 1, 0) = -qp * anv * (t21 * dx1 + t22 * dx2 + t23 * dx3);
    errorPropCurv(n, 1, 1) =
      cost * (v11 * v21 + v12 * v22 + v13 * v23) + sint * (hv1 * v21 + hv2 * v22 + hv3 * v23) +
      omcost * (hn1 * v11 + hn2 * v12 + hn3 * v13) * (hn1 * v21 + hn2 * v22 + hn3 * v23) +
      anv * (-sint * (v11 * t21 + v12 * t22 + v13 * t23) + omcost * (v11 * an1 + v12 * an2 + v13 * an3) -
             tmsint * gamma * (hn1 * v11 + hn2 * v12 + hn3 * v13));
    errorPropCurv(n, 1, 2) = cost * (u11 * v21 + u12 * v22) + sint * (hu1 * v21 + hu2 * v22 + hu3 * v23) +
                      omcost * (hn1 * u11 + hn2 * u12) * (hn1 * v21 + hn2 * v22 + hn3 * v23) +
                      anv * (-sint * (u11 * t21 + u12 * t22) + omcost * (u11 * an1 + u12 * an2) -
                             tmsint * gamma * (hn1 * u11 + hn2 * u12));
    errorPropCurv(n, 1, 2) *= cosl0;
    errorPropCurv(n, 1, 3) = -q * anv * (u11 * t21 + u12 * t22);
    errorPropCurv(n, 1, 4) = -q * anv * (v11 * t21 + v12 * t22 + v13 * t23);
    //   phi
    errorPropCurv(n, 2, 0) = -qp * anu * (t21 * dx1 + t22 * dx2 + t23 * dx3) * cosl1;
    errorPropCurv(n, 2, 1) =
      cost * (v11 * u21 + v12 * u22) + sint * (hv1 * u21 + hv2 * u22) +
      omcost * (hn1 * v11 + hn2 * v12 + hn3 * v13) * (hn1 * u21 + hn2 * u22) +
      anu * (-sint * (v11 * t21 + v12 * t22 + v13 * t23) + omcost * (v11 * an1 + v12 * an2 + v13 * an3) -
             tmsint * gamma * (hn1 * v11 + hn2 * v12 + hn3 * v13));
    errorPropCurv(n, 2, 1) *= cosl1;
    errorPropCurv(n, 2, 2) = cost * (u11 * u21 + u12 * u22) + sint * (hu1 * u21 + hu2 * u22) +
                      omcost * (hn1 * u11 + hn2 * u12) * (hn1 * u21 + hn2 * u22) +
                      anu * (-sint * (u11 * t21 + u12 * t22) + omcost * (u11 * an1 + u12 * an2) -
                             tmsint * gamma * (hn1 * u11 + hn2 * u12));
    errorPropCurv(n, 2, 2) *= cosl1 * cosl0;
    errorPropCurv(n, 2, 3) = -q * anu * (u11 * t21 + u12 * t22) * cosl1;
    errorPropCurv(n, 2, 4) = -q * anu * (v11 * t21 + v12 * t22 + v13 * t23) * cosl1;
    //   yt
    float cutCriterion = fabs(s[n - nmin] * sinT[n - nmin] * inPar(n, 3, 0));
    const float limit = 5.;  // valid for propagations with effectively float precision
    if (cutCriterion > limit) {
      float pp = 1. / qbp;
      errorPropCurv(n, 3, 0) = pp * (u21 * dx1 + u22 * dx2);
      errorPropCurv(n, 4, 0) = pp * (v21 * dx1 + v22 * dx2 + v23 * dx3);
    } else {
      float hp11 = hn2 * t13 - hn3 * t12;
      float hp12 = hn3 * t11 - hn1 * t13;
      float hp13 = hn1 * t12 - hn2 * t11;
      float temp1 = hp11 * u21 + hp12 * u22;
      float s2 = s[n - nmin] * s[n - nmin];
      float secondOrder41 = 0.5 * qp * temp1 * s2;
      float ghnmp1 = gamma * hn1 - t11;
      float ghnmp2 = gamma * hn2 - t12;
      float ghnmp3 = gamma * hn3 - t13;
      float temp2 = ghnmp1 * u21 + ghnmp2 * u22;
      float s3 = s2 * s[n - nmin];
      float s4 = s3 * s[n - nmin];
      float h1 = bF;
      float h2 = h1 * h1;
      float h3 = h2 * h1;
      float qbp2 = qbp * qbp;
      float thirdOrder41 = 1. / 3 * h2 * s3 * qbp * temp2;
      float fourthOrder41 = 1. / 8 * h3 * s4 * qbp2 * temp1;
      errorPropCurv(n, 3, 0) = secondOrder41 + (thirdOrder41 + fourthOrder41);
      float temp3 = hp11 * v21 + hp12 * v22 + hp13 * v23;
      float secondOrder51 = 0.5 * qp * temp3 * s2;
      float temp4 = ghnmp1 * v21 + ghnmp2 * v22 + ghnmp3 * v23;
      float thirdOrder51 = 1. / 3 * h2 * s3 * qbp * temp4;
      float fourthOrder51 = 1. / 8 * h3 * s4 * qbp2 * temp3;
      errorPropCurv(n, 4, 0) = secondOrder51 + (thirdOrder51 + fourthOrder51);
    }
    errorPropCurv(n, 3, 1) = (sint * (v11 * u21 + v12 * u22) + omcost * (hv1 * u21 + hv2 * u22) +
                       tmsint * (hn1 * u21 + hn2 * u22) * (hn1 * v11 + hn2 * v12 + hn3 * v13)) /
                      q;
    errorPropCurv(n, 3, 2) = (sint * (u11 * u21 + u12 * u22) + omcost * (hu1 * u21 + hu2 * u22) +
                       tmsint * (hn1 * u21 + hn2 * u22) * (hn1 * u11 + hn2 * u12)) *
                      cosl0 / q;
    errorPropCurv(n, 3, 3) = (u11 * u21 + u12 * u22);
    errorPropCurv(n, 3, 4) = (v11 * u21 + v12 * u22);
    //   zt
    errorPropCurv(n, 4, 1) = (sint * (v11 * v21 + v12 * v22 + v13 * v23) + omcost * (hv1 * v21 + hv2 * v22 + hv3 * v23) +
                       tmsint * (hn1 * v21 + hn2 * v22 + hn3 * v23) * (hn1 * v11 + hn2 * v12 + hn3 * v13)) /
                      q;
    errorPropCurv(n, 4, 2) = (sint * (u11 * v21 + u12 * v22) + omcost * (hu1 * v21 + hu2 * v22 + hu3 * v23) +
                       tmsint * (hn1 * v21 + hn2 * v22 + hn3 * v23) * (hn1 * u11 + hn2 * u12)) *
                      cosl0 / q;
    errorPropCurv(n, 4, 3) = (u11 * v21 + u12 * v22);
    errorPropCurv(n, 4, 4) = (v11 * v21 + v12 * v22 + v13 * v23);

  }//end loop over n

//debug = true;
#ifdef DEBUG
    for (int n = nmin; n < nmax; ++n) {
      if (debug && g_debug && n < N_proc) {
        dmutex_guard;
        std::cout << n << ": errorPropCurv" << std::endl;
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 0, 0),
               errorPropCurv(n, 0, 1),
               errorPropCurv(n, 0, 2),
               errorPropCurv(n, 0, 3),
               errorPropCurv(n, 0, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 1, 0),
               errorPropCurv(n, 1, 1),
               errorPropCurv(n, 1, 2),
               errorPropCurv(n, 1, 3),
               errorPropCurv(n, 1, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 2, 0),
               errorPropCurv(n, 2, 1),
               errorPropCurv(n, 2, 2),
               errorPropCurv(n, 2, 3),
               errorPropCurv(n, 2, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 3, 0),
               errorPropCurv(n, 3, 1),
               errorPropCurv(n, 3, 2),
               errorPropCurv(n, 3, 3),
               errorPropCurv(n, 3, 4));
        printf("%5f %5f %5f %5f %5f\n",
               errorPropCurv(n, 4, 0),
               errorPropCurv(n, 4, 1),
               errorPropCurv(n, 4, 2),
               errorPropCurv(n, 4, 3),
               errorPropCurv(n, 4, 4));
        printf("\n");
      }
    }
#endif

  //now we need jacobians to convert to/from curvilinear and CCS
  // code from TrackState::jacobianCCSToCurvilinear
  MPlex56  jacCCS2Curv;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii=0;ii<5;ii++) {
      for (int jj=0;jj<6;jj++) {
        jacCCS2Curv(n, ii, jj) = 0.f;
      }
    }
    jacCCS2Curv(n, 0, 3) = inChg(n, 0, 0) * sinT[n];
    jacCCS2Curv(n, 0, 5) = inChg(n, 0, 0) * cosT[n] * inPar(n, 3, 0);
    jacCCS2Curv(n, 1, 5) = -1.f;
    jacCCS2Curv(n, 2, 4) = 1.f;
    jacCCS2Curv(n, 3, 0) = -sinPin[n];
    jacCCS2Curv(n, 3, 1) = cosPin[n];
    jacCCS2Curv(n, 4, 0) = -cosPin[n] * cosT[n];
    jacCCS2Curv(n, 4, 1) = -sinPin[n] * cosT[n];
    jacCCS2Curv(n, 4, 2) = sinT[n];
  }

  // code from TrackState::jacobianCurvilinearToCCS
  MPlex65  jacCurv2CCS;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii=0;ii<6;ii++) {
      for (int jj=0;jj<5;jj++) {
        jacCurv2CCS(n, ii, jj) = 0.f;
      }
    }

    jacCurv2CCS(n, 0, 3) = -sinPout[n];
    jacCurv2CCS(n, 0, 4) = -cosT[n] * cosPout[n];
    jacCurv2CCS(n, 1, 3) = cosPout[n];
    jacCurv2CCS(n, 1, 4) = -cosT[n] * sinPout[n];
    jacCurv2CCS(n, 2, 4) = sinT[n];
    jacCurv2CCS(n, 3, 0) = inChg(n, 0, 0) / sinT[n];
    jacCurv2CCS(n, 3, 1) = outPar(n, 3, 0) * cosT[n] / sinT[n];
    jacCurv2CCS(n, 4, 2) = 1.f;
    jacCurv2CCS(n, 5, 1) = -1.f;
  }

  //need to compute errorProp = jacCurv2CCS*errorPropCurv*jacCCS2Curv
  Matriplex::MPlex<float, 6, 5, NN> tmp;
  Matriplex::multiplyGeneral(jacCurv2CCS, errorPropCurv, tmp);
  Matriplex::multiplyGeneral(tmp, jacCCS2Curv, errorProp);

}


// from P.Avery's notes (http://www.phys.ufl.edu/~avery/fitting/transport.pdf eq. 5)
inline float getS(float delta0, float delta1, float delta2,
                  float eta0, float eta1, float eta2,
	          float sinP, float cosP, float sinT, float cosT,
	          float pt, int q, float kinv) {
  float A = delta0*eta0 + delta1*eta1 + delta2*eta2;
  float ip = sinT/pt;
  float p0[3] = {pt*cosP,pt*sinP,cosT/ip};
  float B = (p0[0]*eta0 + p0[1]*eta1 + p0[2]*eta2) * ip;
  float rho = kinv*ip;
  float C = (eta0*p0[1] - eta1*p0[0]) * rho * 0.5f * ip;
  float sqb2m4ac = std::sqrt( B*B - 4.f*A*C );
  float s1 = (-B + sqb2m4ac)*0.5f/C;
  float s2 = (-B - sqb2m4ac)*0.5f/C;
  //take the closest
  return ( std::abs(s1)>std::abs(s2) ? s2 : s1);
}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtPlane_impl(const Tf& __restrict__ inPar,
                                     const Ti& __restrict__ inChg,
                                     const Tf11& __restrict__ plPnt,
                                     const Tf11& __restrict__ plNrm,
                                     TfLL1& __restrict__ outPar,
                                     TfLLL& __restrict__ errorProp,
                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                     const int nmin,
                                     const int nmax,
                                     const int N_proc,
                                     const PropagationFlags& pf) {
  float kinv[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f * (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0)) ) );
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f * (-Const::sol * Config::Bfield);
    }
  }

  float delta0[nmax - nmin];
  float delta1[nmax - nmin];
  float delta2[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    delta0[n] = inPar(n,0,0)-plPnt(n,0,0);
    delta1[n] = inPar(n,1,0)-plPnt(n,1,0);
    delta2[n] = inPar(n,2,0)-plPnt(n,2,0);
  }

  float sinP[nmax - nmin];
  float cosP[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinP[n] = std::sin(inPar(n,4,0));
    cosP[n] = std::cos(inPar(n,4,0));
  }

  float s[nmax - nmin];
  //first iteration outside the loop
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    s[n] = getS(delta0[n],delta1[n],delta2[n],plNrm(n,0,0), plNrm(n,1,0), plNrm(n,2,0), sinP[n], cosP[n],
                std::sin(inPar(n,5,0)), std::cos(inPar(n,5,0)), inPar(n,3,0), inChg(n,0,0), kinv[n]);
  }

  MPlexLV outParTmp;

  CMS_UNROLL_LOOP_COUNT(Config::Niter-1)
  for (int i = 0; i < Config::Niter-1; ++i) {

    parsFromPathL_impl(inPar, outParTmp, kinv, s, nmin, nmax);

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      delta0[n] = outParTmp(n,0,0)-plPnt(n,0,0);
      delta1[n] = outParTmp(n,1,0)-plPnt(n,1,0);
      delta2[n] = outParTmp(n,2,0)-plPnt(n,2,0);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sinP[n] = std::sin(outParTmp(n,4,0));
      cosP[n] = std::cos(outParTmp(n,4,0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      s[n] += getS(delta0[n],delta1[n],delta2[n],plNrm(n,0,0), plNrm(n,1,0), plNrm(n,2,0), sinP[n], cosP[n],
                   std::sin(inPar(n,5,0)), std::cos(inPar(n,5,0)), inPar(n,3,0), inChg(n,0,0), kinv[n]);
    }

  }//end Niter-1
std::cout << "s=" << s[0] << std::endl;
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, nmin, nmax, N_proc, pf);

}

// this function just calculates the path length (using the iterative approach as before)
// and then calls parsAndErrPropFromPathL_impl for error propagation
template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl_new(const Tf& __restrict__ inPar,
                                                     const Ti& __restrict__ inChg,
                                                     const Tf11& __restrict__ msRad,
                                                     TfLL1& __restrict__ outPar,
                                                     TfLLL& __restrict__ errorProp,
                                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                     const int nmin,
                                                     const int nmax,
                                                     const int N_proc,
                                                     const PropagationFlags& pf) {

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float oodotp[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(xin[n - nmin], yin[n - nmin]);
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * xin[n - nmin] + pyin[n - nmin] * yin[n - nmin]);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] / std::tan(inPar(n, 5, 0)) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n]);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      xin[n - nmin] = xin[n - nmin] + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      yin[n - nmin] = yin[n - nmin] + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float s[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    s[n - nmin] = D[n - nmin]/std::sin(inPar(n, 5, 0));
  }
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, nmin, nmax, N_proc, pf);

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation to R end (NEW), dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << D[n - nmin] * inPar(n, 3, 0) * kinv[n - nmin] << " kinv = " << kinv[n - nmin] << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
		  << " cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif

}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl(const Tf& __restrict__ inPar,
                                                 const Ti& __restrict__ inChg,
                                                 const Tf11& __restrict__ msRad,
                                                 TfLL1& __restrict__ outPar,
                                                 TfLLL& __restrict__ errorProp,
                                                 Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                 const int nmin,
                                                 const int nmax,
                                                 const int N_proc,
                                                 const PropagationFlags& pf) {
  // bool debug = true;

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
  float theta[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    // if (std::abs(r-r0)<0.0001f) {
    // 	dprint("distance less than 1mum, skip");
    // 	continue;
    // }

    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
    theta[n - nmin] = inPar(n, 5, 0);

    //dprint(std::endl);
  }

//debug = true;
  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float dDdx[nmax - nmin];
  float dDdy[nmax - nmin];
  float dDdipt[nmax - nmin];
  float dDdphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdipt[n - nmin] = 0.;
    dDdphi[n - nmin] = 0.;
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //derivatives initialized to value for first iteration, i.e. distance = r-r0in
    dDdx[n - nmin] = r0[n - nmin] > 0.f ? -xin[n - nmin] / r0[n - nmin] : 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdy[n - nmin] = r0[n - nmin] > 0.f ? -yin[n - nmin] / r0[n - nmin] : 0.f;
  }

  float oodotp[nmax - nmin];
  float x[nmax - nmin];
  float y[nmax - nmin];
  float oor0[nmax - nmin];
  float dadipt[nmax - nmin];
  float dadx[nmax - nmin];
  float dady[nmax - nmin];
  float pxca[nmax - nmin];
  float pxsa[nmax - nmin];
  float pyca[nmax - nmin];
  float pysa[nmax - nmin];
  float tmp[nmax - nmin];
  float tmpx[nmax - nmin];
  float tmpy[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(outPar(n, 0, 0), outPar(n, 1, 0));
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * outPar(n, 0, 0) + pyin[n - nmin] * outPar(n, 1, 0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] * std::tan(theta[n - nmin]) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n]);
    }

    //update derivatives on total distance
    if (i + 1 != Config::Niter) {
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        x[n - nmin] = outPar(n, 0, 0);
        y[n - nmin] = outPar(n, 1, 0);
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        oor0[n - nmin] =
            (r0[n - nmin] > 0.f && std::abs(r[n - nmin] - r0[n - nmin]) > 0.0001f) ? 1.f / r0[n - nmin] : 0.f;
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dadipt[n - nmin] = id[n - nmin] * kinv[n - nmin];
        dadx[n - nmin] = -x[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        dady[n - nmin] = -y[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        pxca[n - nmin] = pxin[n - nmin] * cosa[n - nmin];
        pxsa[n - nmin] = pxin[n - nmin] * sina[n - nmin];
        pyca[n - nmin] = pyin[n - nmin] * cosa[n - nmin];
        pysa[n - nmin] = pyin[n - nmin] * sina[n - nmin];
        tmpx[n - nmin] = k[n - nmin] * dadx[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdx[n - nmin] -= (x[n - nmin] * (1.f + tmpx[n - nmin] * (pxca[n - nmin] - pysa[n - nmin])) +
                           y[n - nmin] * tmpx[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin])) *
                          oor0[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        tmpy[n - nmin] = k[n - nmin] * dady[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdy[n - nmin] -= (x[n - nmin] * tmpy[n - nmin] * (pxca[n - nmin] - pysa[n - nmin]) +
                           y[n - nmin] * (1.f + tmpy[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin]))) *
                          oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        //now r0 depends on ipt and phi as well
        tmp[n - nmin] = dadipt[n - nmin] * ipt[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdipt[n - nmin] -= k[n - nmin] *
                            (x[n - nmin] * (pxca[n - nmin] * tmp[n - nmin] - pysa[n - nmin] * tmp[n - nmin] -
                                            pyca[n - nmin] - pxsa[n - nmin] + pyin[n - nmin]) +
                             y[n - nmin] * (pyca[n - nmin] * tmp[n - nmin] + pxsa[n - nmin] * tmp[n - nmin] -
                                            pysa[n - nmin] + pxca[n - nmin] - pxin[n - nmin])) *
                            pt[n - nmin] * oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdphi[n - nmin] += k[n - nmin] *
                            (x[n - nmin] * (pysa[n - nmin] - pxin[n - nmin] + pxca[n - nmin]) -
                             y[n - nmin] * (pxsa[n - nmin] - pyin[n - nmin] + pyca[n - nmin])) *
                            oor0[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      outPar(n, 0, 0) = outPar(n, 0, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      outPar(n, 1, 0) = outPar(n, 1, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float alpha[nmax - nmin];
  float dadphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = D[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadx[n - nmin] = dDdx[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dady[n - nmin] = dDdy[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadipt[n - nmin] = (ipt[n - nmin] * dDdipt[n - nmin] + D[n - nmin]) * kinv[n - nmin];
    dadphi[n - nmin] = dDdphi[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
  }

  if constexpr (Config::useTrigApprox) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin], sina[n - nmin], cosa[n - nmin]);
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = std::cos(alpha[n - nmin]);
      sina[n - nmin] = std::sin(alpha[n - nmin]);
    }
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 0, 0) = 1.f + k[n - nmin] * dadx[n - nmin] *
                                   (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 0, 1) = k[n - nmin] * dady[n - nmin] *
                         (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 0, 2) = 0.f;
    errorProp(n, 0, 3) =
        k[n - nmin] *
        (cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         sinPorT[n - nmin] * ((1.f - cosa[n - nmin]) - ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin])) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 0, 4) =
        k[n - nmin] *
        (cosPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] -
         sinPorT[n - nmin] * sina[n - nmin] + cosPorT[n - nmin] * cosa[n - nmin] - cosPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 0, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 1, 0) = k[n - nmin] * dadx[n - nmin] *
                         (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 1, 1) = 1.f + k[n - nmin] * dady[n - nmin] *
                                   (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 1, 2) = 0.f;
    errorProp(n, 1, 3) =
        k[n - nmin] *
        (sinPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin] - (1.f - cosa[n - nmin]))) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 1, 4) =
        k[n - nmin] *
        (sinPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] +
         sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin] - sinPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 1, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //no trig approx here, theta can be large
    cosPorT[n - nmin] = std::cos(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //redefine sinPorT as 1./sinPorT to reduce the number of temporaries
    sinPorT[n - nmin] = 1.f / sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 2, 0) =
        inPar(n, 2, 0) + k[n - nmin] * alpha[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 0) = k[n - nmin] * cosPorT[n - nmin] * dadx[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 1) = k[n - nmin] * cosPorT[n - nmin] * dady[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 2, 3) = k[n - nmin] * cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] - alpha[n - nmin]) *
                         pt[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 4) = k[n - nmin] * dadphi[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 5) = -k[n - nmin] * alpha[n - nmin] * pt[n - nmin] * sinPorT[n - nmin] * sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 3, 0) = ipt[n - nmin];
    errorProp(n, 3, 0) = 0.f;
    errorProp(n, 3, 1) = 0.f;
    errorProp(n, 3, 2) = 0.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 3, 4) = 0.f;
    errorProp(n, 3, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    errorProp(n, 4, 0) = dadx[n - nmin];
    errorProp(n, 4, 1) = dady[n - nmin];
    errorProp(n, 4, 2) = 0.f;
    errorProp(n, 4, 3) = dadipt[n - nmin];
    errorProp(n, 4, 4) = 1.f + dadphi[n - nmin];
    errorProp(n, 4, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 5, 0) = theta[n - nmin];
    errorProp(n, 5, 0) = 0.f;
    errorProp(n, 5, 1) = 0.f;
    errorProp(n, 5, 2) = 0.f;
    errorProp(n, 5, 3) = 0.f;
    errorProp(n, 5, 4) = 0.f;
    errorProp(n, 5, 5) = 1.f;
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation end, dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << alpha[n - nmin] << " kinv = " << kinv[n - nmin] << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
		  << "   cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif
}
