///////////////////////////////////////////////////////////////////////////////
/// helixAtRFromIterativeCCS_impl
///////////////////////////////////////////////////////////////////////////////

//#define DEBUG
//#include "Debug.h"

namespace
{
  using MPF = MPlexQF;

  MPF getBFieldFromZXY(const MPF &z, const MPF &x, const MPF &y) {
    MPF b;
    for (int n = 0; n < NN; ++n)
      b[n] = Config::bFieldFromZR(z[n], hipo(x[n], y[n]));
    return b;
  }
}

template <typename Tf, typename TfLL1, typename Tf1>
static inline void parsFromPathL_impl(const Tf& __restrict__ inPar,
                                      TfLL1& __restrict__ outPar,
                                      const Tf1& __restrict__ kinv,
                                      const Tf1& __restrict__ s) {
  namespace mpt = Matriplex;
  using MPF = MPlexQF;

  MPF alpha = s * mpt::fast_sin(inPar(5, 0)) * inPar(3, 0) * kinv;

  MPF sinah, cosah;
  if constexpr (Config::useTrigApprox) {
    mpt::sincos4(0.5f * alpha, sinah, cosah);
  } else {
    mpt::fast_sincos(0.5f * alpha, sinah, cosah);
  }

  MPF sin_mom_phi, cos_mom_phi;
  mpt::fast_sincos(inPar(4, 0), sin_mom_phi, cos_mom_phi);

  MPF sin_mom_tht, cos_mom_tht;
  mpt::fast_sincos(inPar(5, 0), sin_mom_tht, cos_mom_tht);

  outPar.aij(0, 0) =
      inPar(0, 0) + 2.f * sinah *
                            (cos_mom_phi * cosah - sin_mom_phi * sinah) /
                            (inPar(3, 0) * kinv);
  outPar.aij(1, 0) =
      inPar(1, 0) + 2.f * sinah *
                            (sin_mom_phi * cosah + cos_mom_phi * sinah) /
                            (inPar(3, 0) * kinv);
  outPar.aij(2, 0) = inPar(2, 0) + alpha / kinv * cos_mom_tht /
                                          (inPar(3, 0) * sin_mom_tht);
  outPar.aij(3, 0) = inPar(3, 0);
  outPar.aij(4, 0) = inPar(4, 0) + alpha;
  outPar.aij(5, 0) = inPar(5, 0);
}

//should kinv and D be templated???
template <typename Tf, typename Ti, typename TfLL1, typename TfLLL, typename Tf1>
inline void parsAndErrPropFromPathL_impl(const Tf& __restrict__ inPar,
                                         const Ti& __restrict__ inChg,
                                         TfLL1& __restrict__ outPar,
                                         const Tf1& __restrict__ kinv,
                                         const Tf1& __restrict__ s,
                                         TfLLL& __restrict__ errorProp,
                                         const int N_proc,
                                         const PropagationFlags& pf) {
  //iteration should return the path length s, then update parameters and compute errors

  namespace mpt = Matriplex;
  using MPF = MPlexQF;

  parsFromPathL_impl(inPar, outPar, kinv, s);

  MPF sinPin, cosPin;
  mpt::fast_sincos(inPar(4, 0), sinPin, cosPin);
  MPF sinPout, cosPout;
  mpt::fast_sincos(outPar(4, 0), sinPout, cosPout);
  MPF sinT, cosT;
  mpt::fast_sincos(inPar(5, 0), sinT, cosT);

  // use code from AnalyticalCurvilinearJacobian::computeFullJacobian for error propagation in curvilinear coordinates, then convert to CCS
  // main difference from the above function is that we assume that the magnetic field is purely along z (which also implies that there is no change in pz)
  // this simplifies significantly the code

  MPlex55 errorPropCurv;

  const MPF qbp = mpt::negate_if_ltz(sinT * inPar(3, 0), inChg);
  // calculate transport matrix
  // Origin: TRPRFN
  const MPF t11 = cosPin * sinT;
  const MPF t12 = sinPin * sinT;
  const MPF t21 = cosPout * sinT;
  const MPF t22 = sinPout * sinT;
  const MPF cosl1 = 1.f / sinT;
  // define average magnetic field and gradient
  // at initial point - inlike TRPRFN
  const MPF bF =
      (pf.use_param_b_field
            ? Const::sol_over_100 * getBFieldFromZXY(inPar(2, 0), inPar(0, 0), inPar(1, 0))
            : Const::sol_over_100 * Config::Bfield);
  const MPF q = -bF * qbp;
  const MPF theta = q * s;
  MPF sint, cost;
  mpt::fast_sincos(theta, sint, cost);
  const MPF dx1 = inPar(0, 0) - outPar(0, 0);
  const MPF dx2 = inPar(1, 0) - outPar(1, 0);
  const MPF dx3 = inPar(2, 0) - outPar(2, 0);
  MPF au = mpt::fast_isqrt(t11 * t11 + t12 * t12);
  const MPF u11 = -au * t12;
  const MPF u12 = au * t11;
  const MPF v11 = -cosT * u12;
  const MPF v12 = cosT * u11;
  const MPF v13 = t11 * u12 - t12 * u11;
  au = mpt::fast_isqrt(t21 * t21 + t22 * t22);
  const MPF u21 = -au * t22;
  const MPF u22 = au * t21;
  const MPF v21 = -cosT * u22;
  const MPF v22 = cosT * u21;
  const MPF v23 = t21 * u22 - t22 * u21;
  // now prepare the transport matrix
  const MPF omcost = 1.f - cost;
  const MPF tmsint = theta - sint;
  //   1/p - doesn't change since |p1| = |p2|
  errorPropCurv.aij(0, 0) = 1.f;
  for (int i = 1; i < 5; ++i)
    errorPropCurv.aij(0, i) = 0.f;
  //   lambda
  errorPropCurv.aij(1, 0) = 0.f;
  errorPropCurv.aij(1, 1) =
      cost * (v11 * v21 + v12 * v22 + v13 * v23) + sint * (-v12 * v21 + v11 * v22) + omcost * v13 * v23;
  errorPropCurv.aij(1, 2) = (cost * (u11 * v21 + u12 * v22) + sint * (-u12 * v21 + u11 * v22)) * sinT;
  errorPropCurv.aij(1, 3) = 0.f;
  errorPropCurv.aij(1, 4) = 0.f;
  //   phi
  errorPropCurv.aij(2, 0) = bF * v23 * (t21 * dx1 + t22 * dx2 + cosT * dx3) * cosl1;
  errorPropCurv.aij(2, 1) = (cost * (v11 * u21 + v12 * u22) + sint * (-v12 * u21 + v11 * u22) +
                            v23 * (-sint * (v11 * t21 + v12 * t22 + v13 * cosT) +
                                    omcost * (-v11 * t22 + v12 * t21) - tmsint * cosT * v13)) *
                            cosl1;
  errorPropCurv.aij(2, 2) = (cost * (u11 * u21 + u12 * u22) + sint * (-u12 * u21 + u11 * u22) +
                            v23 * (-sint * (u11 * t21 + u12 * t22) + omcost * (-u11 * t22 + u12 * t21))) *
                            cosl1 * sinT;
  errorPropCurv.aij(2, 3) = -q * v23 * (u11 * t21 + u12 * t22) * cosl1;
  errorPropCurv.aij(2, 4) = -q * v23 * (v11 * t21 + v12 * t22 + v13 * cosT) * cosl1;

  //   yt
  for (int n = 0; n < N_proc; ++n) {
    float cutCriterion = fabs(s[n] * sinT[n] * inPar(n, 3, 0));
    const float limit = 5.f;  // valid for propagations with effectively float precision
    if (cutCriterion > limit) {
      const float pp = 1.f / qbp[n];
      errorPropCurv(n, 3, 0) = pp * (u21[n] * dx1[n] + u22[n] * dx2[n]);
      errorPropCurv(n, 4, 0) = pp * (v21[n] * dx1[n] + v22[n] * dx2[n] + v23[n] * dx3[n]);
    } else {
      const float temp1 = -t12[n] * u21[n] + t11[n] * u22[n];
      const float s2 = s[n] * s[n];
      const float secondOrder41 = -0.5f * bF[n] * temp1 * s2;
      const float temp2 = -t11[n] * u21[n] - t12[n] * u22[n];
      const float s3 = s2 * s[n];
      const float s4 = s3 * s[n];
      const float h2 = bF[n] * bF[n];
      const float h3 = h2 * bF[n];
      const float qbp2 = qbp[n] * qbp[n];
      const float thirdOrder41 = 1.f / 3 * h2 * s3 * qbp[n] * temp2;
      const float fourthOrder41 = 1.f / 8 * h3 * s4 * qbp2 * temp1;
      errorPropCurv(n, 3, 0) = secondOrder41 + (thirdOrder41 + fourthOrder41);
      const float temp3 = -t12[n] * v21[n] + t11[n] * v22[n];
      const float secondOrder51 = -0.5f * bF[n] * temp3 * s2;
      const float temp4 = -t11[n] * v21[n] - t12[n] * v22[n] - cosT[n] * v23[n];
      const float thirdOrder51 = 1.f / 3 * h2 * s3 * qbp[n] * temp4;
      const float fourthOrder51 = 1.f / 8 * h3 * s4 * qbp2 * temp3;
      errorPropCurv(n, 4, 0) = secondOrder51 + (thirdOrder51 + fourthOrder51);
    }
  }

  errorPropCurv.aij(3, 1) = (sint * (v11 * u21 + v12 * u22) + omcost * (-v12 * u21 + v11 * u22)) / q;
  errorPropCurv.aij(3, 2) = (sint * (u11 * u21 + u12 * u22) + omcost * (-u12 * u21 + u11 * u22)) * sinT / q;
  errorPropCurv.aij(3, 3) = (u11 * u21 + u12 * u22);
  errorPropCurv.aij(3, 4) = (v11 * u21 + v12 * u22);
  //   zt
  errorPropCurv.aij(4, 1) =
      (sint * (v11 * v21 + v12 * v22 + v13 * v23) + omcost * (-v12 * v21 + v11 * v22) + tmsint * v23 * v13) / q;
  errorPropCurv.aij(4, 2) = (sint * (u11 * v21 + u12 * v22) + omcost * (-u12 * v21 + u11 * v22)) * sinT / q;
  errorPropCurv.aij(4, 3) = (u11 * v21 + u12 * v22);
  errorPropCurv.aij(4, 4) = (v11 * v21 + v12 * v22 + v13 * v23);

//debug = true;
#ifdef DEBUG
  for (int n = 0; n < NN; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": errorPropCurv" << std::endl;
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 0, 0),
             errorPropCurv(n, 0, 1),
             errorPropCurv(n, 0, 2),
             errorPropCurv(n, 0, 3),
             errorPropCurv(n, 0, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 1, 0),
             errorPropCurv(n, 1, 1),
             errorPropCurv(n, 1, 2),
             errorPropCurv(n, 1, 3),
             errorPropCurv(n, 1, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 2, 0),
             errorPropCurv(n, 2, 1),
             errorPropCurv(n, 2, 2),
             errorPropCurv(n, 2, 3),
             errorPropCurv(n, 2, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 3, 0),
             errorPropCurv(n, 3, 1),
             errorPropCurv(n, 3, 2),
             errorPropCurv(n, 3, 3),
             errorPropCurv(n, 3, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 4, 0),
             errorPropCurv(n, 4, 1),
             errorPropCurv(n, 4, 2),
             errorPropCurv(n, 4, 3),
             errorPropCurv(n, 4, 4));
      printf("\n");
    }
  }
#endif

  //now we need jacobians to convert to/from curvilinear and CCS
  // code from TrackState::jacobianCCSToCurvilinear
  MPlex56 jacCCS2Curv(0.0f);
  jacCCS2Curv.aij(0, 3) = mpt::negate_if_ltz(sinT, inChg);
  jacCCS2Curv.aij(0, 5) = mpt::negate_if_ltz(cosT, inChg);
  jacCCS2Curv.aij(1, 5) = -1.f;
  jacCCS2Curv.aij(2, 4) = 1.f;
  jacCCS2Curv.aij(3, 0) = -sinPin;
  jacCCS2Curv.aij(3, 1) = cosPin;
  jacCCS2Curv.aij(4, 0) = -cosPin * cosT;
  jacCCS2Curv.aij(4, 1) = -sinPin * cosT;
  jacCCS2Curv.aij(4, 2) = sinT;

  // code from TrackState::jacobianCurvilinearToCCS
  MPlex65 jacCurv2CCS(0.0f);
  jacCurv2CCS.aij(0, 3) = -sinPout;
  jacCurv2CCS.aij(0, 4) = -cosT * cosPout;
  jacCurv2CCS.aij(1, 3) = cosPout;
  jacCurv2CCS.aij(1, 4) = -cosT * sinPout;
  jacCurv2CCS.aij(2, 4) = sinT;
  jacCurv2CCS.aij(3, 0) = mpt::negate_if_ltz(1.f / sinT, inChg);
  jacCurv2CCS.aij(3, 1) = outPar(3, 0) * cosT / sinT;
  jacCurv2CCS.aij(4, 2) = 1.f;
  jacCurv2CCS.aij(5, 1) = -1.f;

  //need to compute errorProp = jacCurv2CCS*errorPropCurv*jacCCS2Curv
  MPlex65 tmp;
  Matriplex::multiplyGeneral(jacCurv2CCS, errorPropCurv, tmp);
  Matriplex::multiplyGeneral(tmp, jacCCS2Curv, errorProp);
}

// from P.Avery's notes (http://www.phys.ufl.edu/~avery/fitting/transport.pdf eq. 5)
inline float getS(float delta0,
                  float delta1,
                  float delta2,
                  float eta0,
                  float eta1,
                  float eta2,
                  float sinP,
                  float cosP,
                  float sinT,
                  float cosT,
                  float pt,
                  int q,
                  float kinv) {
  float A = delta0 * eta0 + delta1 * eta1 + delta2 * eta2;
  float ip = sinT / pt;
  float p0[3] = {pt * cosP, pt * sinP, cosT / ip};
  float B = (p0[0] * eta0 + p0[1] * eta1 + p0[2] * eta2) * ip;
  float rho = kinv * ip;
  float C = (eta0 * p0[1] - eta1 * p0[0]) * rho * 0.5f * ip;
  float sqb2m4ac = std::sqrt(B * B - 4.f * A * C);
  float s1 = (-B + sqb2m4ac) * 0.5f / C;
  float s2 = (-B - sqb2m4ac) * 0.5f / C;
#ifdef DEBUG
  if (debug)
    std::cout << "A=" << A << " B=" << B << " C=" << C << " s1=" << s1 << " s2=" << s2 << std::endl;
#endif
  //take the closest
  return (std::abs(s1) > std::abs(s2) ? s2 : s1);
}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL, typename Tf1>
static inline void helixAtPlane_impl(const Tf& __restrict__ inPar,
                                     const Ti& __restrict__ inChg,
                                     const Tf11& __restrict__ plPnt,
                                     const Tf11& __restrict__ plNrm,
                                     Tf1& __restrict__ s,
                                     TfLL1& __restrict__ outPar,
                                     TfLLL& __restrict__ errorProp,
                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                     const int N_proc,
                                     const PropagationFlags& pf) {
  namespace mpt = Matriplex;
  using MPF = MPlexQF;

#ifdef DEBUG
  for (int n = 0; n < N_proc; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }
#endif

  MPF kinv = mpt::negate_if_ltz(MPF(-Const::sol_over_100), inChg);
  if (pf.use_param_b_field) {
    kinv *= getBFieldFromZXY(inPar(2, 0), inPar(0, 0), inPar(1, 0));
  } else {
    kinv *= Config::Bfield;
  }

  MPF delta0 = inPar(0, 0) - plPnt(0, 0);
  MPF delta1 = inPar(1, 0) - plPnt(1, 0);
  MPF delta2 = inPar(2, 0) - plPnt(2, 0);

  MPF sinP, cosP;
  mpt::fast_sincos(inPar(4, 0), sinP, cosP);
  MPF sinT, cosT;
  mpt::fast_sincos(inPar(5, 0), sinT, cosT);

  // determine solution for straight line
  MPF sl = -(plNrm(0, 0) * delta0 + plNrm(1, 0) * delta1 + plNrm(2, 0) * delta2) /
            (plNrm(0, 0) * cosP * sinT +
             plNrm(1, 0) * sinP * sinT + plNrm(2, 0) * cosT);

  //float s[nmax - nmin];
  //first iteration outside the loop
#pragma omp simd
  for (int n = 0; n < NN; ++n) {
    s[n] = (std::abs(plNrm(n, 2, 0)) < 1.f
                       ? getS(delta0[n],
                              delta1[n],
                              delta2[n],
                              plNrm(n, 0, 0),
                              plNrm(n, 1, 0),
                              plNrm(n, 2, 0),
                              sinP[n],
                              cosP[n],
                              sinT[n],
                              cosT[n],
                              inPar(n, 3, 0),
                              inChg(n, 0, 0),
                              kinv[n])
                       : (plPnt.constAt(n, 2, 0) - inPar.constAt(n, 2, 0)) / cosT[n]);
  }

  MPlexLV outParTmp;

  CMS_UNROLL_LOOP_COUNT(Config::Niter - 1)
  for (int i = 0; i < Config::Niter - 1; ++i) {
    parsFromPathL_impl(inPar, outParTmp, kinv, s);

    delta0 = outParTmp(0, 0) - plPnt(0, 0);
    delta1 = outParTmp(1, 0) - plPnt(1, 0);
    delta2 = outParTmp(2, 0) - plPnt(2, 0);

    mpt::fast_sincos(outParTmp(4, 0), sinP, cosP);
    // Note, sinT/cosT not updated

#pragma omp simd
    for (int n = 0; n < NN; ++n) {
      s[n] += (std::abs(plNrm(n, 2, 0)) < 1.f ? getS(delta0[n],
                                                     delta1[n],
                                                     delta2[n],
                                                     plNrm(n, 0, 0),
                                                     plNrm(n, 1, 0),
                                                     plNrm(n, 2, 0),
                                                     sinP[n],
                                                     cosP[n],
                                                     sinT[n],
                                                     cosT[n],
                                                     inPar(n, 3, 0),
                                                     inChg(n, 0, 0),
                                                     kinv[n])
                                              : (plPnt.constAt(n, 2, 0) - outParTmp.constAt(n, 2, 0)) /
                                                    std::cos(outParTmp.constAt(n, 5, 0)));
    }
  }  //end Niter-1

  // use linear approximation if s did not converge (for very high pT tracks)
  for (int n = 0; n < NN; ++n) {
#ifdef DEBUG
    if (debug)
      std::cout << "s[n]=" << s[n] << " sl[n]=" << sl[n]
                << " std::isnan(s[n])=" << std::isnan(s[n])
                << " std::isfinite(s[n])=" << std::isfinite(s[n])
                << " std::isnormal(s[n])=" << std::isnormal(s[n]) << std::endl;
#endif
    if ((std::abs(sl[n]) > std::abs(s[n])) || std::isnormal(s[n]) == false)
      s[n] = sl[n];
  }

#ifdef DEBUG
  if (debug)
    std::cout << "s=" << s[0] << std::endl;
#endif
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, N_proc, pf);
}

//========================================================================================
// helixAtR
//========================================================================================

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl(const Tf& __restrict__ inPar,
                                                 const Ti& __restrict__ inChg,
                                                 const Tf11& __restrict__ msRad,
                                                 TfLL1& __restrict__ outPar,
                                                 TfLLL& __restrict__ errorProp,
                                                 Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                 const int nmin,
                                                 const int nmax,
                                                 const int N_proc,
                                                 const PropagationFlags& pf) {
  // bool debug = true;

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
  float theta[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    // if (std::abs(r-r0)<0.0001f) {
    // 	dprint("distance less than 1mum, skip");
    // 	continue;
    // }

    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
    theta[n - nmin] = inPar(n, 5, 0);

    //dprint(std::endl);
  }

  //debug = true;
  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float dDdx[nmax - nmin];
  float dDdy[nmax - nmin];
  float dDdipt[nmax - nmin];
  float dDdphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdipt[n - nmin] = 0.;
    dDdphi[n - nmin] = 0.;
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //derivatives initialized to value for first iteration, i.e. distance = r-r0in
    dDdx[n - nmin] = r0[n - nmin] > 0.f ? -xin[n - nmin] / r0[n - nmin] : 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdy[n - nmin] = r0[n - nmin] > 0.f ? -yin[n - nmin] / r0[n - nmin] : 0.f;
  }

  float oodotp[nmax - nmin];
  float x[nmax - nmin];
  float y[nmax - nmin];
  float oor0[nmax - nmin];
  float dadipt[nmax - nmin];
  float dadx[nmax - nmin];
  float dady[nmax - nmin];
  float pxca[nmax - nmin];
  float pxsa[nmax - nmin];
  float pyca[nmax - nmin];
  float pysa[nmax - nmin];
  float tmp[nmax - nmin];
  float tmpx[nmax - nmin];
  float tmpy[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(outPar(n, 0, 0), outPar(n, 1, 0));
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * outPar(n, 0, 0) + pyin[n - nmin] * outPar(n, 1, 0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] * std::tan(theta[n - nmin]) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n - nmin]);
    }

    //update derivatives on total distance
    if (i + 1 != Config::Niter) {
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        x[n - nmin] = outPar(n, 0, 0);
        y[n - nmin] = outPar(n, 1, 0);
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        oor0[n - nmin] =
            (r0[n - nmin] > 0.f && std::abs(r[n - nmin] - r0[n - nmin]) > 0.0001f) ? 1.f / r0[n - nmin] : 0.f;
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dadipt[n - nmin] = id[n - nmin] * kinv[n - nmin];
        dadx[n - nmin] = -x[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        dady[n - nmin] = -y[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        pxca[n - nmin] = pxin[n - nmin] * cosa[n - nmin];
        pxsa[n - nmin] = pxin[n - nmin] * sina[n - nmin];
        pyca[n - nmin] = pyin[n - nmin] * cosa[n - nmin];
        pysa[n - nmin] = pyin[n - nmin] * sina[n - nmin];
        tmpx[n - nmin] = k[n - nmin] * dadx[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdx[n - nmin] -= (x[n - nmin] * (1.f + tmpx[n - nmin] * (pxca[n - nmin] - pysa[n - nmin])) +
                           y[n - nmin] * tmpx[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin])) *
                          oor0[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        tmpy[n - nmin] = k[n - nmin] * dady[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdy[n - nmin] -= (x[n - nmin] * tmpy[n - nmin] * (pxca[n - nmin] - pysa[n - nmin]) +
                           y[n - nmin] * (1.f + tmpy[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin]))) *
                          oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        //now r0 depends on ipt and phi as well
        tmp[n - nmin] = dadipt[n - nmin] * ipt[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdipt[n - nmin] -= k[n - nmin] *
                            (x[n - nmin] * (pxca[n - nmin] * tmp[n - nmin] - pysa[n - nmin] * tmp[n - nmin] -
                                            pyca[n - nmin] - pxsa[n - nmin] + pyin[n - nmin]) +
                             y[n - nmin] * (pyca[n - nmin] * tmp[n - nmin] + pxsa[n - nmin] * tmp[n - nmin] -
                                            pysa[n - nmin] + pxca[n - nmin] - pxin[n - nmin])) *
                            pt[n - nmin] * oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdphi[n - nmin] += k[n - nmin] *
                            (x[n - nmin] * (pysa[n - nmin] - pxin[n - nmin] + pxca[n - nmin]) -
                             y[n - nmin] * (pxsa[n - nmin] - pyin[n - nmin] + pyca[n - nmin])) *
                            oor0[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      outPar(n, 0, 0) = outPar(n, 0, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      outPar(n, 1, 0) = outPar(n, 1, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float alpha[nmax - nmin];
  float dadphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = D[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadx[n - nmin] = dDdx[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dady[n - nmin] = dDdy[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadipt[n - nmin] = (ipt[n - nmin] * dDdipt[n - nmin] + D[n - nmin]) * kinv[n - nmin];
    dadphi[n - nmin] = dDdphi[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
  }

  if constexpr (Config::useTrigApprox) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin], sina[n - nmin], cosa[n - nmin]);
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = std::cos(alpha[n - nmin]);
      sina[n - nmin] = std::sin(alpha[n - nmin]);
    }
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 0, 0) = 1.f + k[n - nmin] * dadx[n - nmin] *
                                   (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 0, 1) = k[n - nmin] * dady[n - nmin] *
                         (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 0, 2) = 0.f;
    errorProp(n, 0, 3) =
        k[n - nmin] *
        (cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         sinPorT[n - nmin] * ((1.f - cosa[n - nmin]) - ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin])) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 0, 4) =
        k[n - nmin] *
        (cosPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] -
         sinPorT[n - nmin] * sina[n - nmin] + cosPorT[n - nmin] * cosa[n - nmin] - cosPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 0, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 1, 0) = k[n - nmin] * dadx[n - nmin] *
                         (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 1, 1) = 1.f + k[n - nmin] * dady[n - nmin] *
                                   (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 1, 2) = 0.f;
    errorProp(n, 1, 3) =
        k[n - nmin] *
        (sinPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin] - (1.f - cosa[n - nmin]))) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 1, 4) =
        k[n - nmin] *
        (sinPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] +
         sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin] - sinPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 1, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //no trig approx here, theta can be large
    cosPorT[n - nmin] = std::cos(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //redefine sinPorT as 1./sinPorT to reduce the number of temporaries
    sinPorT[n - nmin] = 1.f / sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 2, 0) =
        inPar(n, 2, 0) + k[n - nmin] * alpha[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 0) = k[n - nmin] * cosPorT[n - nmin] * dadx[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 1) = k[n - nmin] * cosPorT[n - nmin] * dady[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 2, 3) = k[n - nmin] * cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] - alpha[n - nmin]) *
                         pt[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 4) = k[n - nmin] * dadphi[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 5) = -k[n - nmin] * alpha[n - nmin] * pt[n - nmin] * sinPorT[n - nmin] * sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 3, 0) = ipt[n - nmin];
    errorProp(n, 3, 0) = 0.f;
    errorProp(n, 3, 1) = 0.f;
    errorProp(n, 3, 2) = 0.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 3, 4) = 0.f;
    errorProp(n, 3, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    errorProp(n, 4, 0) = dadx[n - nmin];
    errorProp(n, 4, 1) = dady[n - nmin];
    errorProp(n, 4, 2) = 0.f;
    errorProp(n, 4, 3) = dadipt[n - nmin];
    errorProp(n, 4, 4) = 1.f + dadphi[n - nmin];
    errorProp(n, 4, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 5, 0) = theta[n - nmin];
    errorProp(n, 5, 0) = 0.f;
    errorProp(n, 5, 1) = 0.f;
    errorProp(n, 5, 2) = 0.f;
    errorProp(n, 5, 3) = 0.f;
    errorProp(n, 5, 4) = 0.f;
    errorProp(n, 5, 5) = 1.f;
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation end, dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << alpha[n - nmin] << " kinv = " << kinv[n - nmin]
                  << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
                  << "   cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif
}
